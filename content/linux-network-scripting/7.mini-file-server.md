---
title: "Projet Final : Mini Serveur de Fichiers"
description: "Construire un serveur de fichiers fonctionnel avec authentification en utilisant Netcat et Bash."
---

# Projet Final : Mon Mini Serveur de Fichiers

## Préambule

Vous pouvez utiliser netcat comme serveur en l'exécutant avec un script shell. Lorsque vous exécutez netcat en mode écoute (`nc -l -p <port>`), il attend les connexions entrantes. Cependant, netcat seul ne gère qu'une seule connexion puis se termine.

Pour créer un serveur persistant qui peut gérer plusieurs connexions ou traiter des commandes, vous pouvez rediriger l'entrée et la sortie de netcat vers un script shell. Le script lira les commandes du client et renverra les réponses.

```bash
nc -l -p 8080 | ./my_script.sh
```

Dans cet exemple, lorsqu'un client se connecte au port 8080, netcat passera les données reçues à `my_script.sh` via stdin, et la sortie du script sera renvoyée au client.

**Exercice préliminaire :**
Créez un script simple nommé `echo_server.sh` qui :
- Lit une ligne depuis stdin
- Renvoie la ligne reçue avec un préfixe "Vous avez dit : "
- S'exécute dans une boucle pour gérer plusieurs lignes

Exécutez le serveur en utilisant : `nc -l -p 8080 | ./echo_server.sh`
Dans un autre terminal, connectez-vous en utilisant : `nc localhost 8080`
Tapez un message et voyez-le renvoyé avec le préfixe.

## Partie 1 : Serveur de fichiers de base

### Objectif

Créez un serveur de fichiers simple qui peut transférer des fichiers entre machines sur le réseau. Le serveur doit supporter les commandes suivantes :
- `help` : Afficher les commandes disponibles
- `list` : Lister tous les fichiers dans un répertoire de données
- `get <file>` : Télécharger un fichier (le contenu du fichier doit être encodé en base64)
- `put <file> <base64_data>` : Téléverser un fichier (aucune authentification requise pour le moment)

### Exigences

1. **Créer un répertoire de données** : Créez un répertoire nommé `data` où les fichiers seront stockés.
2. **Créer le script serveur** : Votre script doit :
   - S'exécuter dans une boucle infinie (`while true`)
   - Lire les commandes depuis stdin (une ligne à la fois)
   - Parser la commande et ses paramètres en utilisant `cut`
   - Utiliser une instruction `case` pour gérer les différentes commandes
   - Pour la commande `get` : lire le fichier depuis le répertoire `data`, l'encoder en base64 et l'envoyer
   - Pour la commande `put` : décoder les données base64 et sauvegarder le fichier dans le répertoire `data`
   - Pour la commande `list` : lister les fichiers dans le répertoire `data`
   - Pour la commande `help` : afficher les commandes disponibles
3. **Utiliser l'encodage base64** : Les fichiers doivent être transmis sous forme de chaînes encodées en base64 pour gérer les données binaires en toute sécurité sur des protocoles basés sur le texte.
4. **Rendre le script exécutable** : Utilisez `chmod +x` pour rendre votre script serveur exécutable.
5. **Exécuter le serveur** : Démarrez le serveur en utilisant : `nc -l -p <port> | ./your_server_script.sh`

::tip
**Indices pour l'implémentation :**
- Utilisez `cut` pour parser les paramètres de commande depuis la ligne d'entrée
- Utilisez `basename` pour vous assurer que les chemins de fichiers ne contiennent pas de tentatives de traversée de répertoire
- Utilisez `base64 -w0` pour encoder les fichiers (l'option `-w0` empêche le retour à la ligne)
- Utilisez `base64 -d` pour décoder les données base64
- Utilisez `ls -1` pour lister les fichiers un par ligne
- N'oubliez pas d'ajouter des lignes vides (`echo ""`) après chaque réponse pour séparer clairement les sorties de commandes
- Gérez les commandes invalides gracieusement
::

### Tester votre serveur

Une fois que vous avez implémenté votre serveur de fichiers, testez-le en :
1. Démarrage du serveur sur un port
2. Connexion depuis un autre terminal (ou une autre machine si disponible)
3. Test de toutes les commandes : `help`, `list`, `get`, et `put`
4. Téléversement d'un fichier en utilisant `put`, puis listage des fichiers avec `list`, et téléchargement avec `get`

## Partie 2 : Authentification et Sécurité

### Objectif

Améliorez votre serveur de fichiers en ajoutant l'authentification pour garantir que seuls les utilisateurs autorisés peuvent téléverser des fichiers. La commande `put` doit maintenant exiger un nom d'utilisateur et un mot de passe.

### Comprendre le hachage SHA256

SHA256 est une fonction de hachage cryptographique qui prend des données d'entrée et produit une valeur de hachage de taille fixe (256 bits). La même entrée produira toujours le même hachage, mais il est très difficile d'inverser le processus.
Cela rend le hachage utile pour stocker les mots de passe de manière sécurisée.

### Créer une base de données d'authentification

Pour générer un hachage pour un utilisateur :
```bash
printf "username:password" | sha256sum
```

Pour stocker cela dans un fichier de base de données d'authentification :
```bash
printf "username:password" | sha256sum > auth_db
```

### Vérifier l'authentification

Pour vérifier si une combinaison nom d'utilisateur et mot de passe est valide, vous devez :
1. Combiner le nom d'utilisateur et le mot de passe au format "username:password"
2. Calculer son hachage SHA256
3. Vérifier si ce hachage existe dans le fichier `auth_db`

Exemple de vérification :
```bash
printf "username:password" | sha256sum -c auth_db
```

### Exigences

1. **Créer une base de données d'authentification** : Créez un fichier nommé `auth_db` avec les identifiants des utilisateurs. Ajoutez au moins deux utilisateurs de test à la base de données.
2. **Modifier la commande `put` dans votre script serveur** :
   - Changez le format de commande de `put <file> <base64_data>` à `put <user> <password> <file> <base64_data>`
   - Extrayez le nom d'utilisateur et le mot de passe
   - Vérifiez le hachage contre `auth_db`
   - Procédez uniquement si l'authentification réussit
3. **Mettre à jour la commande `help`** : Changez le message d'aide pour refléter le nouveau format de commande `put`.

::tip
**Indices pour l'implémentation :**
- Pour la vérification : `printf "$username:$password" | sha256sum -c auth_db 2>/dev/null | grep -q "OK"`
- Utilisez `continue` pour ignorer la commande si l'authentification échoue
::

### Code Serveur de Référence

::code-collapse
# Code Reference
```bash
#!/bin/bash

while true; do
	read line
	cmd=$(echo $line | cut -d' ' -f1)
	param1=$(echo $line | cut -d' ' -f2)
	param2=$(echo $line | cut -d' ' -f3)
	param3=$(echo $line | cut -d' ' -f4)
	param4=$(echo $line | cut -d' ' -f5)
	case $cmd in
		help)
			echo "help"
			echo "list"
			echo "get <file>"
			echo "put <user> <password> <file> <base64_data>"
			echo ""
			;;
		list)
			ls -1 data
			echo ""
			;;
		get)
			cat data/$(basename $param1) | base64 -w0
			echo ""
			;;
		put)
			printf "$param1:$param2" | sha256sum -c auth_db 2>/dev/null | grep -q "OK" || continue
			echo $param4 | base64 -d > data/$(basename $param3)
			echo ""
			;;
		*)
			echo "Invalid command"
			echo ""
			;;
	esac
done
```
::
